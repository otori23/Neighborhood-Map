
1) The "foreach" binding

- the foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item 

- this is especially useful for rendering lists or tables

- assuming your array is an observable array, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match 

- can use a native (static) js array with foreach binding, but don't get automatic UI refresh

- inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements

- you can arbitrarily nest any number of foreach bindings along with other control-flow bindings such as if and with

2) Iterating over static array

<table>
    <thead>
        <tr><th>First name</th><th>Last name</th></tr>
    </thead>
    <tbody data-bind="foreach: people">
        <tr>
            <td data-bind="text: firstName"></td>
            <td data-bind="text: lastName"></td>
        </tr>
    </tbody>
</table>
 
<script type="text/javascript">
    ko.applyBindings({
        people: [
            { firstName: 'Bert', lastName: 'Bertington' },
            { firstName: 'Charles', lastName: 'Charlesforth' },
            { firstName: 'Denise', lastName: 'Dentiste' }
        ]
    });
</script>

3) Iterating over observable array

===== Source code: View =====

<h4>People</h4>
<ul data-bind="foreach: people">
    <li>
        Name at position <span data-bind="text: $index"> </span>:
        <span data-bind="text: name"> </span>
        <a href="#" data-bind="click: $parent.removePerson">Remove</a>
    </li>
</ul>
<button data-bind="click: addPerson">Add</button>

===== Source code: View model =====

function AppViewModel() {
    var self = this;
 
    self.people = ko.observableArray([
        { name: 'Bert' },
        { name: 'Charles' },
        { name: 'Denise' }
    ]);
 
    self.addPerson = function() {
        self.people.push({ name: "New at " + new Date() });
    };
 
    self.removePerson = function() {
        self.people.remove(this);
    }
}
 
ko.applyBindings(new AppViewModel());

4) foreach: JS Object Literal

- pass a JavaScript object literal with a property called data which is the array you wish to iterate over

<ul data-bind="foreach: { data: people, as: 'person' }"></ul>

5) Referring to each array entry using $data

- $data is a special context property 
- within a foreach block, $data means “the current item”
- in previous examples, bindings within the foreach block directly refered to properties on the array entries
- e.g. the firstName and lastName properties on each array entry (see item #2)

<ul data-bind="foreach: months">
    <li>
        The current item is: <b data-bind="text: $data"></b>
    </li>
</ul>
 
<script type="text/javascript">
    ko.applyBindings({
        months: [ 'Jan', 'Feb', 'Mar', 'etc' ]
    });
</script>

5a) <td data-bind="text: $data.firstName"></td>

- works but is not necessary
- within the foreach block, the context changes to that of the array entry

6) Using $index, $parent, and other context properties

6a) $index

- refers to the zero-based index of the current array item
- is an observable and is updated whenever the index of the item changes 
- e.g., if items are added to or removed from the array

6b) $parent

- use $parent to refer to data from outside the foreach
- i.e. change the context from the object that is the array item ($data) to the object that contains the array itself
which is in most cases the view model itself

7) Binding Context

- think of it as the JS object whose properties I will be refering to directly

8) Using “as” to give an alias to “foreach” items

- in some cases though, it may be useful to give the current item a more descriptive name using the 'as' option

<ul data-bind="foreach: { data: people, as: 'person' }"></ul>

- remember to pass a string literal value to as (e.g., as: 'person', not as: person)
- because you are giving a name for a new variable, not reading the value of a variable that already exists

8a) When to use 'as'

- can be especially useful in scenarios where you have nested foreach blocks ... 
- and you need to refer to an item declared at a higher level in the hierarchy 

<ul data-bind="foreach: { data: categories, as: 'category' }">
    <li>
        <ul data-bind="foreach: { data: items, as: 'item' }">
            <li>
                <span data-bind="text: category.name"></span>:
                <span data-bind="text: item"></span>
            </li>
        </ul>
    </li>
</ul>
 
<script>
    var viewModel = {
        categories: ko.observableArray([
            { name: 'Fruit', items: [ 'Apple', 'Orange', 'Banana' ] },
            { name: 'Vegetables', items: [ 'Celery', 'Corn', 'Spinach' ] }
        ])
    };
    ko.applyBindings(viewModel);
</script>

9) Using foreach without a container element

- remember the "containerless control flow syntax": <!-- ko --> and <!-- /ko -->
- use when you don’t have any container element on which to put a foreach binding

== Example ==
<ul>
    <li class="header">Header item</li>
    <!-- The following are generated dynamically from an array -->
    <li>Item A</li>
    <li>Item B</li>
    <li>Item C</li>
</ul>

- can’t put foreach: binding on the <ul> because then you’d be duplicating the header item
- to handle this, you can use the containerless control flow syntax

<ul>
    <li class="header">Header item</li>
    <!-- ko foreach: myItems -->
        <li>Item <span data-bind="text: $data"></span></li>
    <!-- /ko -->
</ul>
 
<script type="text/javascript">
    ko.applyBindings({
        myItems: [ 'A', 'B', 'C' ]
    });
</script>

10) Destroyed entries are hidden by default

Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a non-destructive delete. For details of how to do this, see the destroy function on observableArray.

By default, the foreach binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the includeDestroyed option. For example,

<div data-bind='foreach: { data: myArray, includeDestroyed: true }'>
    ...
</div>

11) Post-processing or animating the generated DOM elements

- if you need to run some further custom logic on the generated DOM elements, you can use any of the afterRender/afterAdd/beforeRemove/beforeMove/afterMove callbacks described below

- these callbacks are only intended for triggering animations related to changes in a list

== EXAMPLE: afterAdd callback; requires JQuery color plubing ==

<ul data-bind="foreach: { data: myItems, afterAdd: yellowFadeIn }">
    <li data-bind="text: $data"></li>
</ul>
 
<button data-bind="click: addItem">Add</button>
 
<script type="text/javascript">
    ko.applyBindings({
        myItems: ko.observableArray([ 'A', 'B', 'C' ]),
        yellowFadeIn: function(element, index, data) {
            $(element).filter("li")
                      .animate({ backgroundColor: 'yellow' }, 200)
                      .animate({ backgroundColor: 'white' }, 800);
        },
        addItem: function() { this.myItems.push('New item'); }
    });
</script>

12) The "if" binding

- the if binding causes a section of markup to appear in your document 
- the other data-bind attributes of the markup is applied only when the if binding expression evaluates to true

12a) if vs visible

12b) visible

- the contained markup always remains in the DOM and always has its data-bind attributes applied 
- the visible binding just uses CSS to toggle the container element’s visiblity

12c) if

- physically adds or removes the contained markup in your DOM
- only applies bindings to descendants if the expression is true

== Example ==

Source code: View

<label><input type="checkbox" data-bind="checked: displayMessage" /> Display message</label>
 
<div data-bind="if: displayMessage">Here is a message. Astonishing.</div>

Source code: View model

ko.applyBindings({
    displayMessage: ko.observable(false)
});

== Example ==

- it iss important to understand that the if binding really is vital to make this code work properly. 
- without it, there would be an error when trying to evaluate capital.cityName in the context of “Mercury” where capital is null

<ul data-bind="foreach: planets">
    <li>
        Planet: <b data-bind="text: name"> </b>
        <div data-bind="if: capital">
            Capital: <b data-bind="text: capital.cityName"> </b>
        </div>
    </li>
</ul>
 
 
<script>
    ko.applyBindings({
        planets: [
            { name: 'Mercury', capital: null }, 
            { name: 'Earth', capital: { cityName: 'Barnsley' } }        
        ]
    });
</script>

13) Using “if” without a container element

<ul>
    <li>This item always appears</li>
    <!-- ko if: someExpressionGoesHere -->
        <li>I want to make this item present/absent dynamically</li>
    <!-- /ko -->
</ul>

14) The "ifnot" binding

- the ifnot binding is exactly the same as the if binding
- except that it inverts the result of whatever expression you pass to it

<div data-bind="ifnot: someProperty">...</div>

… is equivalent to the following:

<div data-bind="if: !someProperty()">...</div>

- the only reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier

15) The "with" binding

The with binding creates a new binding context, so that descendant elements are bound in the context of a specified object.

Of course, you can arbitrarily nest with bindings along with the other control-flow bindings such as if and foreach.

== Example 1 ==

<h1 data-bind="text: city"> </h1>
<p data-bind="with: coords">
    Latitude: <span data-bind="text: latitude"> </span>,
    Longitude: <span data-bind="text: longitude"> </span>
</p>
 
<script type="text/javascript">
    ko.applyBindings({
        city: "London",
        coords: {
            latitude:  51.5001524,
            longitude: -0.1262362
        }
    });
</script>

=== Example 2 ===

Source code: View

<form data-bind="submit: getTweets">
    Twitter account:
    <input data-bind="value: twitterName" />
    <button type="submit">Get tweets</button>
</form>
 
<div data-bind="with: resultData">
    <h3>Recent tweets fetched at <span data-bind="text: retrievalDate"> </span></h3>
    <ol data-bind="foreach: topTweets">
        <li data-bind="text: text"></li>
    </ol>
 
    <button data-bind="click: $parent.clearResults">Clear tweets</button>
</div>

Source code: View model

function AppViewModel() {
    var self = this;
    self.twitterName = ko.observable('@example');
    self.resultData = ko.observable(); // No initial value
 
    self.getTweets = function() {
        var name = self.twitterName(),
            simulatedResults = [
                { text: name + ' What a nice day.' },
                { text: name + ' Building some cool apps.' },
                { text: name + ' Just saw a famous celebrity eating lard. Yum.' }
            ];
 
        self.resultData({ retrievalDate: new Date(), topTweets: simulatedResults });
    }
 
    self.clearResults = function() {
        self.resultData(undefined);
    }
}
 
ko.applyBindings(new AppViewModel());

- note: If the expression you supply evaluates to null or undefined, descendant elements will not be bound at all, but will instead be removed from the document

- this is used in the clearResults method in example 2

16) Using “with” without a container element

<ul>
    <li>Header element</li>
    <!-- ko with: outboundFlight -->
        ...
    <!-- /ko -->
    <!-- ko with: inboundFlight -->
        ...
    <!-- /ko -->
</ul>

17) The "component" binding

- the component binding injects a specified component into an element, and optionally passes parameters to it.