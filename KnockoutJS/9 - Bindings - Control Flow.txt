
1) The "foreach" binding

- the foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item 

- this is especially useful for rendering lists or tables

- assuming your array is an observable array, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match 

- can use a native (static) js array with foreach binding, but don't get automatic UI refresh

- inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements

- you can arbitrarily nest any number of foreach bindings along with other control-flow bindings such as if and with

2) Iterating over static array

<table>
    <thead>
        <tr><th>First name</th><th>Last name</th></tr>
    </thead>
    <tbody data-bind="foreach: people">
        <tr>
            <td data-bind="text: firstName"></td>
            <td data-bind="text: lastName"></td>
        </tr>
    </tbody>
</table>
 
<script type="text/javascript">
    ko.applyBindings({
        people: [
            { firstName: 'Bert', lastName: 'Bertington' },
            { firstName: 'Charles', lastName: 'Charlesforth' },
            { firstName: 'Denise', lastName: 'Dentiste' }
        ]
    });
</script>

3) Iterating over observable array

===== Source code: View =====

<h4>People</h4>
<ul data-bind="foreach: people">
    <li>
        Name at position <span data-bind="text: $index"> </span>:
        <span data-bind="text: name"> </span>
        <a href="#" data-bind="click: $parent.removePerson">Remove</a>
    </li>
</ul>
<button data-bind="click: addPerson">Add</button>

===== Source code: View model =====

function AppViewModel() {
    var self = this;
 
    self.people = ko.observableArray([
        { name: 'Bert' },
        { name: 'Charles' },
        { name: 'Denise' }
    ]);
 
    self.addPerson = function() {
        self.people.push({ name: "New at " + new Date() });
    };
 
    self.removePerson = function() {
        self.people.remove(this);
    }
}
 
ko.applyBindings(new AppViewModel());

4) foreach: JS Object Literal

- pass a JavaScript object literal with a property called data which is the array you wish to iterate over

<ul data-bind="foreach: { data: people, as: 'person' }"></ul>

5) Referring to each array entry using $data

- $data is a special context property 
- within a foreach block, $data means “the current item”
- in previous examples, bindings within the foreach block directly refered to properties on the array entries
- e.g. the firstName and lastName properties on each array entry (see item #2)

<ul data-bind="foreach: months">
    <li>
        The current item is: <b data-bind="text: $data"></b>
    </li>
</ul>
 
<script type="text/javascript">
    ko.applyBindings({
        months: [ 'Jan', 'Feb', 'Mar', 'etc' ]
    });
</script>

5a) <td data-bind="text: $data.firstName"></td>

- works but is not necessary
- within the foreach block, the context changes to that of the array entry

6) Using $index, $parent, and other context properties

6a) $index

- refers to the zero-based index of the current array item
- is an observable and is updated whenever the index of the item changes 
- e.g., if items are added to or removed from the array

6b) $parent

- use $parent to refer to data from outside the foreach
- i.e. change the context from the object that is the array item ($data) to the object that contains the array itself
which is in most cases the view model itself

7) Binding Context

- think of it as the JS object whose properties I will be refering to directly

8) Using “as” to give an alias to “foreach” items

- in some cases though, it may be useful to give the current item a more descriptive name using the 'as' option

<ul data-bind="foreach: { data: people, as: 'person' }"></ul>

- remember to pass a string literal value to as (e.g., as: 'person', not as: person)
- because you are giving a name for a new variable, not reading the value of a variable that already exists

8a) When to use 'as'

- can be especially useful in scenarios where you have nested foreach blocks ... 
- and you need to refer to an item declared at a higher level in the hierarchy 

<ul data-bind="foreach: { data: categories, as: 'category' }">
    <li>
        <ul data-bind="foreach: { data: items, as: 'item' }">
            <li>
                <span data-bind="text: category.name"></span>:
                <span data-bind="text: item"></span>
            </li>
        </ul>
    </li>
</ul>
 
<script>
    var viewModel = {
        categories: ko.observableArray([
            { name: 'Fruit', items: [ 'Apple', 'Orange', 'Banana' ] },
            { name: 'Vegetables', items: [ 'Celery', 'Corn', 'Spinach' ] }
        ])
    };
    ko.applyBindings(viewModel);
</script>

9) Using foreach without a container element

- remember the "containerless control flow syntax": <!-- ko --> and <!-- /ko -->
- use when you don’t have any container element on which to put a foreach binding

== Example ==
<ul>
    <li class="header">Header item</li>
    <!-- The following are generated dynamically from an array -->
    <li>Item A</li>
    <li>Item B</li>
    <li>Item C</li>
</ul>

- can’t put foreach: binding on the <ul> because then you’d be duplicating the header item
- to handle this, you can use the containerless control flow syntax

<ul>
    <li class="header">Header item</li>
    <!-- ko foreach: myItems -->
        <li>Item <span data-bind="text: $data"></span></li>
    <!-- /ko -->
</ul>
 
<script type="text/javascript">
    ko.applyBindings({
        myItems: [ 'A', 'B', 'C' ]
    });
</script>

10) Destroyed entries are hidden by default

Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a non-destructive delete. For details of how to do this, see the destroy function on observableArray.

By default, the foreach binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the includeDestroyed option. For example,

<div data-bind='foreach: { data: myArray, includeDestroyed: true }'>
    ...
</div>

11) Post-processing or animating the generated DOM elements

- if you need to run some further custom logic on the generated DOM elements, you can use any of the afterRender/afterAdd/beforeRemove/beforeMove/afterMove callbacks described below

- these callbacks are only intended for triggering animations related to changes in a list

== EXAMPLE: afterAdd callback; requires JQuery color plubing ==

<ul data-bind="foreach: { data: myItems, afterAdd: yellowFadeIn }">
    <li data-bind="text: $data"></li>
</ul>
 
<button data-bind="click: addItem">Add</button>
 
<script type="text/javascript">
    ko.applyBindings({
        myItems: ko.observableArray([ 'A', 'B', 'C' ]),
        yellowFadeIn: function(element, index, data) {
            $(element).filter("li")
                      .animate({ backgroundColor: 'yellow' }, 200)
                      .animate({ backgroundColor: 'white' }, 800);
        },
        addItem: function() { this.myItems.push('New item'); }
    });
</script>

12) The "if" binding

- the if binding causes a section of markup to appear in your document 
- the other data-bind attributes of the markup is applied only when the if binding expression evaluates to true

12a) if vs visible

12b) visible

- the contained markup always remains in the DOM and always has its data-bind attributes applied 
- the visible binding just uses CSS to toggle the container element’s visiblity

12c) if

- physically adds or removes the contained markup in your DOM
- only applies bindings to descendants if the expression is true

== Example ==

Source code: View

<label><input type="checkbox" data-bind="checked: displayMessage" /> Display message</label>
 
<div data-bind="if: displayMessage">Here is a message. Astonishing.</div>

Source code: View model

ko.applyBindings({
    displayMessage: ko.observable(false)
});

== Example ==

- it iss important to understand that the if binding really is vital to make this code work properly. 
- without it, there would be an error when trying to evaluate capital.cityName in the context of “Mercury” where capital is null

<ul data-bind="foreach: planets">
    <li>
        Planet: <b data-bind="text: name"> </b>
        <div data-bind="if: capital">
            Capital: <b data-bind="text: capital.cityName"> </b>
        </div>
    </li>
</ul>
 
 
<script>
    ko.applyBindings({
        planets: [
            { name: 'Mercury', capital: null }, 
            { name: 'Earth', capital: { cityName: 'Barnsley' } }        
        ]
    });
</script>

13) Using “if” without a container element

<ul>
    <li>This item always appears</li>
    <!-- ko if: someExpressionGoesHere -->
        <li>I want to make this item present/absent dynamically</li>
    <!-- /ko -->
</ul>

14) The "ifnot" binding

- the ifnot binding is exactly the same as the if binding
- except that it inverts the result of whatever expression you pass to it

<div data-bind="ifnot: someProperty">...</div>

… is equivalent to the following:

<div data-bind="if: !someProperty()">...</div>

- the only reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier

15) The "with" binding

The with binding creates a new binding context, so that descendant elements are bound in the context of a specified object.

Of course, you can arbitrarily nest with bindings along with the other control-flow bindings such as if and foreach.

== Example 1 ==

<h1 data-bind="text: city"> </h1>
<p data-bind="with: coords">
    Latitude: <span data-bind="text: latitude"> </span>,
    Longitude: <span data-bind="text: longitude"> </span>
</p>
 
<script type="text/javascript">
    ko.applyBindings({
        city: "London",
        coords: {
            latitude:  51.5001524,
            longitude: -0.1262362
        }
    });
</script>

=== Example 2 ===

Source code: View

<form data-bind="submit: getTweets">
    Twitter account:
    <input data-bind="value: twitterName" />
    <button type="submit">Get tweets</button>
</form>
 
<div data-bind="with: resultData">
    <h3>Recent tweets fetched at <span data-bind="text: retrievalDate"> </span></h3>
    <ol data-bind="foreach: topTweets">
        <li data-bind="text: text"></li>
    </ol>
 
    <button data-bind="click: $parent.clearResults">Clear tweets</button>
</div>

Source code: View model

function AppViewModel() {
    var self = this;
    self.twitterName = ko.observable('@example');
    self.resultData = ko.observable(); // No initial value
 
    self.getTweets = function() {
        var name = self.twitterName(),
            simulatedResults = [
                { text: name + ' What a nice day.' },
                { text: name + ' Building some cool apps.' },
                { text: name + ' Just saw a famous celebrity eating lard. Yum.' }
            ];
 
        self.resultData({ retrievalDate: new Date(), topTweets: simulatedResults });
    }
 
    self.clearResults = function() {
        self.resultData(undefined);
    }
}
 
ko.applyBindings(new AppViewModel());

- note: If the expression you supply evaluates to null or undefined, descendant elements will not be bound at all, but will instead be removed from the document

- this is used in the clearResults method in example 2

16) Using “with” without a container element

<ul>
    <li>Header element</li>
    <!-- ko with: outboundFlight -->
        ...
    <!-- /ko -->
    <!-- ko with: inboundFlight -->
        ...
    <!-- /ko -->
</ul>

17) The "component" binding

- the component binding injects a specified component into an element, and optionally passes parameters to it
- like grouping a view model object and markup template (HTML) into a single unit
- the template bindings are written wrt the attached view model
 
Source code: View

<h4>First instance, without parameters</h4>
<div data-bind='component: "message-editor"'></div>
 
<h4>Second instance, passing parameters</h4>
<div data-bind='component: {
    name: "message-editor",
    params: { initialText: "Hello, world!" }
}'></div>

Source code: View model

ko.components.register('message-editor', {
    viewModel: function(params) {
        this.text = ko.observable(params && params.initialText || '');
    },
    template: 'Message: <input data-bind="value: text" /> '
            + '(length: <span data-bind="text: text().length"></span>)'
});
 
ko.applyBindings();

18) Two ways to use component binding

- Shorthand syntax
- Full syntax

18a) Shorthand syntax

- if you pass just a string, it is interpreted as a component name
- the named component is then injected without supplying any parameters to it

<div data-bind='component: "my-component"'></div>

- the shorthand value can also be observable
- in this case, if it changes, the component binding will dispose the old component instance, and inject the newly-referenced component

<div data-bind='component: observableWhoseValueIsAComponentName'></div>

18b) Full syntax

- instead of passing a string name to the the component binding
- pass an object with the following properties:

name — the name of the component to inject. Again, this can be observable.
params — an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component’s viewmodel constructor.

<div data-bind='component: {
    name: "shopping-cart",
    params: { mode: "detailed-list", items: productsList }
}'></div>

Note that whenever a component is removed (either because the name observable changed, or because an enclosing control-flow binding removed the entire element), the removed component is disposed.

19) Component lifecycle

- your component loaders are asked to supply the viewmodel factory and template
- the component template is cloned and injected into the container element
- if the component has a viewmodel, it is instantiated
- the viewmodel is bound to the view
- the component is active
- the component is torn down, and the viewmodel is disposed

20) Template-only components

- components usually have viewmodels, but they don’t necessarily have to
- a component can specify just a template
- in this case, the object to which the component’s view is bound is the params object that you passed to the component binding

=== Example ===

ko.components.register('special-offer', {
    template: '<div class="offer-box" data-bind="text: productName"></div>'
});

… can be injected with:

<div data-bind='component: {
     name: "special-offer-callout",
     params: { productName: someProduct.name }
}'></div>

21) Using component without a container element

<!-- ko component: "message-editor" -->
<!-- /ko -->

… or passing parameters:

<!-- ko component: {
    name: "message-editor",
    params: { initialText: "Hello, world!", otherParam: 123 }
} -->
<!-- /ko -->

22) Passing markup to components

The element you attach a component binding to may contain further markup. For example,

<div data-bind="component: { name: 'my-special-list', params: { items: someArrayOfPeople } }">
    <!-- Look, here's some arbitrary markup. By default it gets stripped out
         and is replaced by the component output. -->
    The person <em data-bind="text: name"></em>
    is <em data-bind="text: age"></em> years old.
</div>

Although the DOM nodes in this element will be stripped out and not bound by default, they are not lost. Instead, they are supplied to the component (in this case, my-special-list), which can include them in its output however it wishes.

23) Disposal and memory management

Optionally, your viewmodel class may have a dispose function. If implemented, Knockout will call this whenever the component is being torn down and removed from the DOM 

23a) Details of 'dispose'

- you must use dispose to release any resources that aren’t inherently garbage-collectable, e.g.

- setInterval callbacks will continue to fire until explicitly cleared (use clearInterval)
- ko.computed properties continue to receive notifications from their dependencies until explicitly disposed
- Subscriptions to observables continue to fire until explicitly disposed
- Manually-created event handlers on external DOM elements, if created inside a createViewModel function (or even inside a regular component viewmodel, although to fit the MVVM pattern you shouldn’t) must be removed

23b) Managing disposals - best practices

- to avoid having to remember which things need disposal, you may prefer to use pureComputed wherever possible, and explicitly dispose all other computeds/subscriptions whether technically necessary or not

=== Example ===

var someExternalObservable = ko.observable(123);
 
function SomeComponentViewModel() {
    this.myComputed = ko.computed(function() {
        return someExternalObservable() + 1;
    }, this);
 
    this.myPureComputed = ko.pureComputed(function() {
        return someExternalObservable() + 2;
    }, this);
 
    this.mySubscription = someExternalObservable.subscribe(function(val) {
        console.log('The external observable changed to ' + val);
    }, this);
 
    this.myIntervalHandle = window.setInterval(function() {
        console.log('Another second passed, and the component is still alive.');
    }, 1000);
}
 
SomeComponentViewModel.prototype.dispose = function() {
    this.myComputed.dispose();
    this.mySubscription.dispose();
    window.clearInterval(this.myIntervalHandle);
    // this.myPureComputed doesn't need to be manually disposed.
}
 
ko.components.register('your-component-name', {
    viewModel: SomeComponentViewModel,
    template: 'some template'
});
