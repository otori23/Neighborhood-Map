
1) Computed Observables

- an observable whose value depends on the value of other observables
- these are functions that are dependent on one or more other observables
- they will automatically update whenever any of these dependencies change

// JS
function AppViewModel() {
    this.firstName = ko.observable('Bob');
    this.lastName = ko.observable('Smith');

    this.fullName = ko.computed(function() {
        return this.firstName() + " " + this.lastName();
    }, this);
}

// HTML

The name is <span data-bind="text: fullName"></span>

2) Managing ‘this’

- a popular convention that avoids the need to track this altogether
- cache the result of this in the view model function

function AppViewModel() {
    var self = this;
 
    self.firstName = ko.observable('Bob');
    self.lastName = ko.observable('Smith');
    self.fullName = ko.computed(function() {
        return self.firstName() + " " + self.lastName();
    });
}

3) Pure computed observables

- use if observable simply calculates and returns a value based on some observable dependencies
- e.g. ko.pureComputed instead of a ko.computed
- its evaluator does not directly modify other objects or state
- Knockout can more efficiently manage its re-evaluation and memory use
- Knockout will automatically suspend or release it if no other code has an active dependency on it.

4) Forcing computed observables to always notify subscribers

- When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed

- can force notification no matter what

myViewModel.fullName = ko.pureComputed(function() {
    return myViewModel.firstName() + " " + myViewModel.lastName();
}).extend({ notify: 'always' });

5) Delaying and/or suppressing change notifications

// Ensure updates no more than once per 50-millisecond period
myViewModel.fullName.extend({ rateLimit: 50 });

6) Determining if a property is a computed observable

- use utility function, ko.isComputed to help with this situation
- you might want to exclude computed observables from data that you are sending back to the server

for (var prop in myObject) {
  if (myObject.hasOwnProperty(prop) && !ko.isComputed(myObject[prop])) {
      result[prop] = myObject[prop];
  }
}

6a) ko.isObservable 

- returns true for observables, observable arrays, and all computed observables

6b) ko.isWritableObservable 

- returns true for observables, observable arrays, and writable computed observables (also aliased as ko.isWriteableObservable)

7) When the computed observable is only used in your UI

If you only need to use the compound full name in the UI you could declare it as:

function AppViewModel() {
    // ... leave firstName and lastName unchanged ...
 
    this.fullName = function() {
        return this.firstName() + " " + this.lastName();
    };
}

Now your binding in UI elements becomes a method call, e.g.:

The name is <span data-bind="text: fullName()"></span>
