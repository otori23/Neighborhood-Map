
1) Observables

- Knockout is built around three core features:
(a) Observables and dependency tracking
(b) Declarative bindings
(c) Templating
(Honorable mention: Automatic UI refresh)

2) MVVM and View Models

- Model-View-View Model (MVVM) is a design pattern for building user interfaces

2a) Model

- your app's stored (persisted) data; typically server-side
- with KO, you will make AKAX calls to server-side code to read/write stored model data

2b) View Model

- a pure-code representation of the data and operations on a UI
- it holds the unsaved (not persisted) data the user is working with
- data that will be bound to UI elements

2c) View

- a visible, interactive UI representing the state of the view model. 
- it displays information from the view model
- it sends commands to the view model (e.g., when the user clicks buttons)
- it updates whenever the state of the view model changes

3) Usage Pattern

3a) Create Model - any js object

var myViewModel = {
    personName: 'Bob',
    personAge: 123
};

3b) Create View with declarative bindings

The name is <span data-bind="text: personName"></span>

3c) Activate Knockout

ko.applyBindings(myViewModel);

4) ko.applyBindings

- The first parameter says what view model object you want to use with the declarative bindings it activates

- Optionally, you can pass a second parameter to define which part of the document you want to search for data-bind attributes. For example, ko.applyBindings(myViewModel, document.getElementById('someElementId')). This restricts the activation to the element with ID someElementId and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.

5) KO Observables

- special JavaScript objects that can notify subscribers about changes
- can also automatically detect dependencies
- think of them as functions that you will call to set or get model value

var myViewModel = {
    personName: ko.observable('Bob'),
    personAge: ko.observable(123)
};

myViewModel.personName() 	// will return 'Bob'
myViewModel.personName('Mary')  // will change the name value to 'Mary'

5a) Chaining Syntax

myViewModel.personName('Mary').personAge(50) // will change the name value to 'Mary' and the age value to 50

7) Subscribing to Observables

7a) Declarative Binding in HTML

- automatically subscribes to observable

- data-bind="text: personName", the text binding registered itself to be notified when personName changes (assuming it’s an observable value, which it is now).

- when you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element

7b) Explicitly subscribing to observables

- you won’t normally need to set up subscriptions manually
- call subscribe funtion of observable

myViewModel.personName.subscribe(function(newValue) {
    alert("The person's new name is " + newValue);
});

7c) The subscribe function (change event)

- accepts three parameters

- callback: the function that is called whenever the notification happens
- target (optional): defines the value of this in the callback function
- event (optional; default is "change") is the name of the event to receive notification for

myViewModel.personName.subscribe(function(newValue) {
    alert("The person's new name is " + newValue);
});

7d) Terminate a subscription

var subscription = myViewModel.personName.subscribe(function(newValue) { /* do stuff */ });
// ...then later...
subscription.dispose(); // I no longer want notifications

7e) beforeChange event

- If you want to be notified of the value of an observable before it is about to be changed,
- you can subscribe to the beforeChange event

myViewModel.personName.subscribe(function(oldValue) {
    alert("The person's previous name is " + oldValue);
}, null, "beforeChange");

7f) Forcing observables to always notify subscribers (notify extender)

- observers are normally only notified if the value actually changed
- may set observable to thesame value it already had; therefore change event won't fire
- to ensure observable event always fires, use notify extender on obersvable

myViewModel.personName.extend({ notify: 'always' });

7g) Delaying and/or suppressing change notifications (rateLimit extender)

- for improved performance of constantly triggered obervable event

// Ensure it notifies about changes no more than once per 50-millisecond period
myViewModel.personName.extend({ rateLimit: 50 });

