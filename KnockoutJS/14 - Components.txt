
0) Recommended pattern for component creation

- use single AMD module for template and viewmodel

1) Components overview

- components are a powerful, clean way of organizing your UI code into self-contained, reusable chunks
- packages view and optionally view model together
- a component definition specifies a viewModel and template

1a) Benefits for Large Application

- simplifies development through clear organization and encapsulation
- helps to improve runtime performance by incrementally loading your application code and templates as needed

2) Custom elements

- optional, but convenient syntax for consuming components
- alternative to using placeholder divs (with binding attributes) into which rendered compnent templates are injected
- you can use more self-descriptive markup with custom element names (e.g., <voting-button> or <product-editor>)

3) ko.components.register

- use to register your components

4) Example of component

- normally, you’d load the view model and template from external files 
- instead of declaring them inline like below

ko.components.register('like-widget', {
    viewModel: function(params) {
        // Data: value is either null, 'like', or 'dislike'
        this.chosenValue = params.value;
         
        // Behaviors
        this.like = function() { this.chosenValue('like'); }.bind(this);
        this.dislike = function() { this.chosenValue('dislike'); }.bind(this);
    },
    template:
        '<div class="like-or-dislike" data-bind="visible: !chosenValue()">\
            <button data-bind="click: like">Like it</button>\
            <button data-bind="click: dislike">Dislike it</button>\
        </div>\
        <div class="result" data-bind="visible: chosenValue">\
            You <strong data-bind="text: chosenValue"></strong> it\
        </div>'
}); 

4a) Using the component

- you can reference it from any other view in your application, either using the component binding or using a custom element

5) Loading the like/dislike widget from external files, on demand

ko.components.register('like-or-dislike', {
    viewModel: { require: 'files/component-like-widget' },
    template: { require: 'text!files/component-like-widget.html' }
});

- in most applications, you’ll want to keep component view models and templates in external files
- if you configure Knockout to fetch them via an AMD module loader such as require.js, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed

5a) Requirements to load external files

- files need to exist
- you need to have referenced a suitable module loader library (such as require.js) or 
- implemented a custom component loader that knows how to grab your files

5b) Using the custom component

- now like-or-dislike can be consumed in the same way as before...
- using either a component binding or a custom element... <like-or-dislike>

5c) Example

Source code: View

<ul data-bind="foreach: products">
    <li class="product">
        <strong data-bind="text: name"></strong>
        <like-or-dislike params="value: userRating"></like-or-dislike>
    </li>
</ul>
<button data-bind="click: addProduct">Add a product</button>

Source code: View model

function Product(name, rating) {
    this.name = name;
    this.userRating = ko.observable(rating || null);
}
 
function MyViewModel() {
    this.products = ko.observableArray(); // Start empty
}
 
MyViewModel.prototype.addProduct = function() {
    var name = 'Product ' + (this.products().length + 1);
    this.products.push(new Product(name));
};
 
ko.applyBindings(new MyViewModel());

6) Component registration: ko.components.register

7) Registering components as a viewmodel/template pair

ko.components.register('some-component-name', {
    viewModel: <see below>,
    template: <see below>
});

8) Specifying a viewmodel

- a constructor function
- a shared object instance
- a createViewModel factory function
- an AMD module whose value describes a viewmodel 

8a) Returned AMD moduel object can be

- any one of the four forms of viewModel mentioned above

9) Specifying a template

- an existing element ID
- An existing element instance
- A string of markup
- An array of DOM nodes
- A document fragment
- An AMD module whose value describes a template

9a) Returned AMD moduel object can be 

- any one of the 6 forms of template mentioned above

10) Additional component options: synchronous property

ko.components.register('my-component', {
    viewModel: { ... anything ... },
    template: { ... anything ... },
    synchronous: true // Injects synchronously if already loaded, otherwise still async
});

11) Registering components as a single AMD module

- for even better encapsulation, you can package a component (template and viewmodel) into a single self-describing AMD module

- ko.components.register('my-component', { require: 'some/module' });

12) Custom elements

- basically just use the name of your registered component like a regular html element tag
- syntactic alternative to the component bindings
- uses component bindings behind the scene
- this allows for a very modern, WebComponents-like way to organize your code...
- while retaining support for even very old browsers

13) Custom elements: Example

Source code: View

<h4>First instance, without parameters</h4>
<message-editor></message-editor>
 
<h4>Second instance, passing parameters</h4>
<message-editor params='initialText: "Hello, world!"'></message-editor>

Source code: View model

ko.components.register('message-editor', {
    viewModel: function(params) {
        this.text = ko.observable(params.initialText || '');
    },
    template: 'Message: <input data-bind="value: text" /> '
            + '(length: <span data-bind="text: text().length"></span>)'
});

14) Component's viewmodel vs Parent view model

- myModelValue is referencing data in the parent view model of some-component
- i.e. NOT the 
<some-component
    params='...
	    someModelProperty: myModelValue,
	    ..'>
</some-component>
ko.applyBindings(); 

15) Passing observable expressions

<some-component
    params='simpleExpression: 1 + 1,
            simpleObservable: myObservable,
            observableExpression: myObservable() + 1'>
</some-component>

- simpleExpression: passed as literal value
- simpleObservable: passed as observable
- observableExpression: passed as computed

16) Passing markup into components

<my-special-list params="items: someArrayOfPeople">
    <!-- Look, I'm putting markup inside a custom element -->
    The person <em data-bind="text: name"></em>
    is <em data-bind="text: age"></em> years old.
</my-special-list>

- DOM nodes inside <my-special-list> will be stripped out and replaced by the component’s output
- DOM nodes supplied to component in two ways
- As an array, $componentTemplateNodes, available to any binding expression in the component’s template
- As an array, componentInfo.templateNodes, passed to its createViewModel function

17) Controlling custom element tag names

- by convention, your custom element tag names correspond exactly to the names of components registered using ko.components.register (i,e, convention-over-configuration)

- use ko.components.getComponentNameForNode to register custom tag names for components

18) Note: Combining custom elements with regular bindings

- a custom element can have a regular data-bind attribute (in addition to any params attribute) if needed
- however, it does not make sense to use bindings that would modify the element’s contents
- e.g. the text or template bindings, would overwrite the template injected by your component

19) Note: Custom elements cannot be self-closing

- you must write <my-custom-element></my-custom-element>, and not <my-custom-element />

20) Note: Custom elements and Internet Explorer 6 to 8

- pre HTML5 browsers 
- need special processing to allow browser to recognize your custom tag for components
- do one of the following

- Ensure you call ko.components.register('your-component') before the HTML parser sees any <your-component> elements

- Or, at least call document.createElement('your-component') before the HTML parser sees any <your-component> elements. You can ignore the result of the createElement call — all that matters is that you have called it.

21) Advanced: Accessing $raw parameters

- normally you will not need to work with $raw

<some-component
    params='myExpr: useObservable1() ? observable1 : observable2'>
</some-component>

function MyComponentViewModel(params) {
    var currentObservableInstance = params.$raw.myExpr();
     
    // Now currentObservableInstance is either observable1 or observable2
    // and you would read its value with "currentObservableInstance()"
}

22) Component loaders

- whenever you inject a component using the component binding or a custom element, Knockout fetches that component’s template and viewmodel using one or more component loaders. 

- the job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name

23) The default component loader

- the built-in default component loader, ko.components.defaultLoader

24) Component loader utility functions

24a) ko.components.register(name, configuration)

- Registers a component. See: full documentation

24b) ko.components.isRegistered(name)

- Returns true if a component with the specified name is already registered; false otherwise

24c) ko.components.unregister(name)

- Removes the named component from the registry. Or if no such component was registered, does nothing

24d) others

- ko.components.get(name, callback)
- ko.components.clearCachedDefinition(name)
- ko.components.defaultLoader.getConfig(name, callback)
- ko.components.defaultLoader.loadComponent(name, componentConfig, callback)
- ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)
- ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)

25) Implementing a custom component loader

- spin your own component loader if,
- you want to use naming conventions, rather than explicit registration, to load components
- or, if you want to use a third-party “loader” library to fetch component viewmodels or templates from external locations

26) Functions you can implement

A custom component loader is simply an object whose properties are any combination of the following functions:

26a) getConfig(name, callback)

- Define this if: you want to supply configurations programmatically based on names, e.g., to implement a naming convention

26b) loadComponent(name, componentConfig, callback)

- Define this if: you want to take control over how component configurations are interpreted, e.g., if you do not want to use the standard viewModel/template pair format.

26c) loadTemplate(name, templateConfig, callback)

- Define this if: you want to use custom logic to supply DOM nodes for a given template configuration (e.g., using an ajax request to fetch a template by URL).

26d) loadViewModel(name, templateConfig, callback)

- Define this if: you want to use custom logic to supply a viewmodel factory for a given viewmodel configuration (e.g., integrating with a third-party module loader or dependency injection system).

27) Registering custom component loaders

- Knockout allows you to use multiple component loaders simultaneously
- ko.components.loaders is an array containing all the loaders currently enabled
- By default, this array contains just one item: ko.components.defaultLoader
- To add additional loaders, simply insert them into the ko.components.loaders array

28) Controlling precedence

- If you want your custom loader to take precedence over the default loader 
(so it gets the first opportunity to supply configuration/values), then add it to the beginning of the array. 

- If you want the default loader to take precedence (so your custom loader is only called for components not explicitly registered), then add it to the end of the array

// Adds myLowPriorityLoader to the end of the loaders array.
// It runs after other loaders, only if none of them returned a value.
ko.components.loaders.push(myLowPriorityLoader);
 
// Adds myHighPriorityLoader to the beginning of the loaders array.
// It runs before other loaders, getting the first chance to return values.
ko.components.loaders.unshift(myHighPriorityLoader)

29) Sequence of calls

- i.e. what the KO framework calls as it executes

30) Browserify vs. RequireJS

- Browserify is a build-time tool
- Browserify is a popular library for referencing JavaScript libraries with a Node-style synchronous require syntax - It’s often considered as an alternative to an AMD loader such as require.js
- However Browserify solves a rather different problem: synchronous build-time reference resolution, rather than asynchronous runtime reference resolution as handled by AMD (i.e. require.js) 