
1) Pure computed observables

- provide performance and memory benefits over regular computed observables
- prevents memory leaks
- reduces computation overhead

2) States

A pure computed observable automatically switches between two states based on whether it has change subscribers.

2a) Sleeping

- Whenever it has no change subscribers, it is sleeping
- When entering the sleeping state, it disposes all subscriptions to its dependencies 
- During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). 
- If the computed observable’s value is read while it is sleeping, it is automatically re-evaluated if any of its dependencies have changed

2b) Listening

Whenever it has any change subscribers, it is awake and listening. 
- When entering the listening state, it immediately subscribes to any dependencies. 
- In this state, it operates just like a regular computed observable, as described in how dependency tracking works.

3) Syntax

this.fullName = ko.pureComputed(function() {
    return this.firstName() + " " + this.lastName();
}, this);

- OR - 

this.fullName = ko.computed(function() {
    return this.firstName() + " " + this.lastName();
}, this, { pure: true });

4) When not to use a pure computed observable

- you shouldn’t use a pure computed if the evaluator has important side effects
- i.e. the evaluator invokes some kind of call back
- the reason is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping)

5) State-change notifications

- will not normally need to do this

this.someComputedThatWillBeBound = ko.pureComputed(function () {
    ...
}, this);
 
this.someComputedThatWillBeBound.subscribe(function () {
    // do something when this is bound
}, this, "awake");
 
this.someComputedThatWillBeBound.subscribe(function () {
    // do something when this is un-bound
}, this, "asleep");