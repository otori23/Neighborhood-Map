
1) The "template" binding

- The template binding populates the associated DOM element with the results of rendering a template
- It’s not very often that you’ll need to use named templates, but on occasion it can help to minimise duplication of markup

2) There are two main ways of using templates

2a) Native templating 

- this  mechanism that underpins foreach, if, with, and other control flow bindings. 

2b) String-based templating 

- a way to connect Knockout to a third-party template engine e.g. jquery.tmpl and Underscore template engines

3) Parameters

For more control, pass a JavaScript object with some combination of the following properties:

- name: the ID of an element that contains the template you wish to render
- nodes: directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for name.
- data: an object to supply as the data for the template to render. If you omit this parameter, KO will look for a foreach parameter, or will fall back on using your current model object.
- if: if this parameter is provided, the template will only be rendered if the specified expression evaluates to true (or a true-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.
- foreach: instructs KO to render the template in “foreach” mode
- as: when used in conjunction with foreach, defines an alias for each item being rendered
- afterRender, afterAdd, or beforeRemove: callback functions to be invoked against the rendered DOM elements

4) <script type="text/html">

-  the dummy type attribute is necessary to ensure that the markup is not executed as JavaScript
- Knockout does not attempt to apply bindings to that markup except when it is being used as a template

5) 'as' additional parameter

- Remember to pass a string literal value to as (e.g., as: 'season', not as: season), because you are giving a name for a new variable, not reading the value of a variable that already exists 

6) Using “afterRender”, “afterAdd”, and “beforeRemove”

- allows you to run custom logic on renderd items
- e.g. can pass rendered output into JQuery UI to turn your renderd html into date pickers, sliders, etc

<div data-bind='template: { name: "personTemplate",
                            data: myData,
                            afterRender: myPostProcessingLogic }'> </div>

viewModel.myPostProcessingLogic = function(elements) {
    // "elements" is an array of DOM nodes just rendered by the template
    // You can add custom post-processing logic here
}

7) Dynamically choosing which template is used

- If you have multiple named templates, you can pass an observable for the name option 
- As the observable’s value is updated, the element’s contents will be re-rendered using the appropriate template - Alternatively, you can pass a callback function to determine which template to use

8) Using jQuery.tmpl, an external string-based template engine

- reference the libraries in order

<!-- First jQuery -->     <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
<!-- Then jQuery.tmpl --> <script src="jquery.tmpl.js"></script>
<!-- Then Knockout -->    <script src="knockout-x.y.z.js"></script>

- then, you can use jQuery.tmpl syntax in your templates. For example,

<h1>People</h1>
<div data-bind="template: 'peopleList'"></div>
 
<script type="text/html" id="peopleList">
    {{each people}}
        <p>
            <b>${name}</b> is ${age} years old
        </p>
    {{/each}}
</script>
 
<script type="text/javascript">
    var viewModel = {
        people: ko.observableArray([
            { name: 'Rod', age: 123 },
            { name: 'Jane', age: 125 },
        ])
    }
    ko.applyBindings(viewModel);
</script>

Please note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout’s native DOM-based templating (i.e., the foreach, if, with, etc. bindings) instead of jQuery.tmpl or any other string-based template engine

9) Using the Underscore.js template engine

<script type="text/html" id="peopleList">
    <% _.each(people(), function(person) { %>
        <li>
            <b><%= person.name %></b> is <%= person.age %> years old
        </li>
    <% }) %>
</script>

9a) Underscore.js template engine: Detailed example

http://jsfiddle.net/rniemeyer/NW5Vn/
