
1) Creating custom bindings

- You’re not limited to using the built-in bindings like click, value, etc ...
- you can create your own 
- this is how KO controls how observables interact with DOM elements, 
- custon bindins givee you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way
- i.e. you can create interactive components like grids, tabsets, and so on, in the form of custom bindings
- see the grid example: http://knockoutjs.com/examples/grid.html

2) Registering your binding

- to register a binding, add it as a subproperty of ko.bindingHandlers:

ko.bindingHandlers.yourBindingName = {
    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        // This will be called when the binding is first applied to an element
        // Set up any initial state, event handlers, etc. here
    },
    update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        // This will be called once when the binding is first applied to an element,
        // and again whenever any observables/computeds that are accessed change
        // Update the DOM element based on the supplied values here.
    }
};

 and then you can use it on any number of DOM elements:

<div data-bind="yourBindingName: someValue"> </div>

Note: you don’t actually have to provide both init and update callbacks — you can just provide one or the other if that’s all you need.

3) The “update” callback - parameters

- element: The DOM element involved in this binding

- valueAccessor: A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value. To easily accept both observable and plain values, call ko.unwrap on the returned value

- allBindings: A JavaScript object that you can use to access all the model values bound to this DOM element. Call allBindings.get('name') to retrieve the value of the name binding (returns undefined if the binding doesn’t exist); or allBindings.has('name') to determine if the name binding is present for the current element

- viewModel: This parameter is deprecated in Knockout 3.x. Use bindingContext.$data or bindingContext.$rawData to access the view model instead.

- bindingContext: An object that holds the binding context available to this element’s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.

4) Custom binding example: Main parameter = 'slideVisible'; Additional parameter = 'slideDuration'

- you want elements to slide into and out of existence according to the value of an observable
- you can do this by writing a custom binding that calls jQuery’s slideUp/slideDown functions

ko.bindingHandlers.slideVisible = {
    update: function(element, valueAccessor, allBindings) {
        // First get the latest data that we're bound to
        var value = valueAccessor();
 
        // Next, whether or not the supplied model property is observable, get its current value
        var valueUnwrapped = ko.unwrap(value);
 
        // Grab some more data from another binding property
        var duration = allBindings.get('slideDuration') || 400; // 400ms is default duration unless otherwise specified
 
        // Now manipulate the DOM element
        if (valueUnwrapped == true)
            $(element).slideDown(duration); // Make the element visible
        else
            $(element).slideUp(duration);   // Make the element invisible
    }
};

- Now you can use this binding as follows

<div data-bind="slideVisible: giftWrap, slideDuration:600">You have selected the option</div>
<label><input type="checkbox" data-bind="checked: giftWrap" /> Gift wrap</label>
 
<script type="text/javascript">
    var viewModel = {
        giftWrap: ko.observable(true)
    };
    ko.applyBindings(viewModel);
</script>


- Now you can reuse your custom binding in many more places

5) The “init” callback

- Knockout will call your init function once for each DOM element that you use the binding on
- same parameters as update
- two main uses: setup initial state or register event handlers for DOM elements on which the binding is applied

5a) Example

- continuing the previous example, 
- you might want slideVisible to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state

ko.bindingHandlers.slideVisible = {
    init: function(element, valueAccessor) {
        var value = ko.unwrap(valueAccessor()); // Get the current value of the current property we're bound to
        $(element).toggle(value); // jQuery will hide/show the element depending on whether "value" or true or false
    },
    update: function(element, valueAccessor, allBindings) {
        // Leave as before
    }
};

6) Modifying observables after DOM events

- previously use 'update' to change observable on user action: UI -> view model property
- now, want 'update' to change UI when view model changes UI <- view model property

- basically, 

- set up event handler in 'init' that will change view model properies on some user event
- the changes in view model property will cause 'update' to run which will then change UI components

ko.bindingHandlers.hasFocus = {
    init: function(element, valueAccessor) {
        $(element).focus(function() {
            var value = valueAccessor();
            value(true);
        });
        $(element).blur(function() {
            var value = valueAccessor();
            value(false);
        });
    },
    update: function(element, valueAccessor) {
        var value = valueAccessor();
        if (ko.unwrap(value))
            element.focus();
        else
            element.blur();
    }
};

<p>Name: <input data-bind="hasFocus: editingName" /></p>
 
<!-- Showing that we can both read and write the focus state -->
<div data-bind="visible: editingName">You're editing the name</div>
<button data-bind="enable: !editingName(), click:function() { editingName(true) }">Edit name</button>
 
<script type="text/javascript">
    var viewModel = {
        editingName: ko.observable()
    };
    ko.applyBindings(viewModel);
</script>


7) Creating custom bindings that control descendant bindings

- not something you will do regularly
- an advanced technique for creating resuable library of bindings

- by default, bindings only affect the element to which they are applied
- but what if you want to affect all descendant elements too?

- simply return { controlsDescendantBindings: true } from your binding’s init function


8) Creating custom bindings that support virtual elements

- not something you will do regularly
- an advanced technique for creating resuable library of bindings

8a) 'foreach' binding example

<ul>
    <li class="heading">My heading</li>
    <!-- ko foreach: items -->
        <li data-bind="text: $data"></li>
    <!-- /ko -->
</ul>

8b) supporting virtual elements

- use ko.virtualElements API to tell KO that your custom binding supports virtual elements
- use ko.virtualElements.allowedBindings.yourBinding = true; to enalbe virtual element support
- use ko.virtualElements for DOM manipulation (instead of standard DOM API) in 'init'/'update' methods

- virtual element APIs tuned for performing custom control flow bindings

9) Custom disposal logic

- it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout

10) Registering a callback on the disposal of an element: ko.utils.domNodeDisposal.addDisposeCallback(node, callback)

---- EXAMPLES ----

ko.bindingHandlers.myWidget = {
    init: function(element, valueAccessor) {
        var options = ko.unwrap(valueAccessor()),
            $el = $(element);
 
        $el.myWidget(options);
 
        ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
            // This will be called when the element is removed by Knockout or
            // if some other part of your code calls ko.removeNode(element)
            $el.myWidget("destroy"); // call the destroy method of the widget
        });
    }
};

11) Overriding the clean-up of external data

- override ko.utils.domNodeDisposal.cleanExternalData(node)

ko.utils.domNodeDisposal.cleanExternalData = function () {
    // Do nothing. Now any jQuery data associated with elements will
    // not be cleaned up when the elements are removed from the DOM.
};

- in case you want to override default implementation...
- which calls calls jQuery’s cleanData method if jQuery is loaded in your page