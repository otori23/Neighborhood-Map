
1) The "click" binding

- the click binding adds an event handler to the selected DOM element
- the event handler will be invoked when the associated DOM element is clicked
- you can reference any JavaScript function - it doesn’t have to be a function on your view model

<div>
    You've clicked <span data-bind="text: numberOfClicks"></span> times
    <button data-bind="click: incrementClickCounter">Click me</button>
</div>
 
<script type="text/javascript">
    var viewModel = {
        numberOfClicks : ko.observable(0),
        incrementClickCounter : function() {
            var previousCount = this.numberOfClicks();
            this.numberOfClicks(previousCount + 1);
        }
    };
</script>

2) Passing a “current item” as a parameter to your handler function

- when calling your handler, Knockout will supply the current model value as the first parameter

<ul data-bind="foreach: places">
    <li>
        <span data-bind="text: $data"></span>
        <button data-bind="click: $parent.removePlace">Remove</button>
    </li>
</ul>
 
 <script type="text/javascript">
     function MyViewModel() {
         var self = this;
         self.places = ko.observableArray(['London', 'Paris', 'Tokyo']);
 
         // The current item will be passed as the first parameter, so we know which place to remove
         self.removePlace = function(place) {
             self.places.remove(place)
         }
     }
     ko.applyBindings(new MyViewModel());
</script>

3) Accessing the event object

- in some scenarios, you may need to access the DOM event object associated with your click event
- Knockout will pass the event as the second parameter to your function

<button data-bind="click: myFunction">
    Click me
</button>
 
 <script type="text/javascript">
    var viewModel = {
        myFunction: function(data, event) {
            if (event.shiftKey) {
                //do something different when user has shift key down
            } else {
                //do normal action
            }
        }
    };
    ko.applyBindings(viewModel);
</script>

4) Passing more parameters

<button data-bind="click: function(data, event) { myFunction('param1', 'param2', data, event) }">
    Click me
</button>

--- same as ---

<button data-bind="click: myFunction.bind($data, 'param1', 'param2')">
    Click me
</button>

5) Allowing the default click action

- if you do want to let the default click action proceed, just return true from your click handler function

- By default, Knockout will prevent the click event from taking any default action
- e.g. if you use the click binding on an a tag, the event handler will run, but the browser will not navigate to the link's href

6) Preventing the event from bubbling

- by default, Knockout will allow the click event to continue to bubble up to any higher level event handlers
- e.g. if your element and a parent of that element are both handling the click event, then the click handler for both elements will be triggered

- you can prevent the event from bubbling by including an additional binding that is named clickBubble and passing false to it

<div data-bind="click: myDivHandler">
    <button data-bind="click: myButtonHandler, clickBubble: false">
        Click me
    </button>
</div>

- normally, in this case myButtonHandler would be called first
- then the click event would bubble up to myDivHandler
- however, the clickBubble binding that we added with a value of false prevents the event from making it past myButtonHandler

7) The "event" binding

- more generic mechanisim for binding DOM events to event handlers in ko view model

<div>
    <div data-bind="event: { mouseover: enableDetails, mouseout: disableDetails }">
        Mouse over me
    </div>
    <div data-bind="visible: detailsEnabled">
        Details
    </div>
</div>
 
<script type="text/javascript">
    var viewModel = {
        detailsEnabled: ko.observable(false),
        enableDetails: function() {
            this.detailsEnabled(true);
        },
        disableDetails: function() {
            this.detailsEnabled(false);
        }
    };
    ko.applyBindings(viewModel);
</script>

8) Passing a “current item” as a parameter to your handler function

- When calling your handler, Knockout will supply the current model value as the first parameter

9) Accessing the event object

- Knockout will pass the event as the second parameter to your event handler function

10) Passing more parameters

- event binding is assigne a function that wraps the event handler in the view model which accepts the extra args
- or -
- use event: eventhandler.bind(thisarg, 'param 1', 'param 2', ...)

11) Allowing the default action

- event handler should return true

12) Preventing the event from bubbling

- event: {event: eventhandler}, eventBubble: false 

<div data-bind="event: { mouseover: myDivHandler }">
    <button data-bind="event: { mouseover: myButtonHandler }, mouseoverBubble: false">
        Click me
    </button>
</div>

13) The "submit" binding

- The submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted

<form data-bind="submit: doSomething">
    ... form contents go here ...
    <button type="submit">Submit</button>
</form>
 
<script type="text/javascript">
    var viewModel = {
        doSomething : function(formElement) {
            // ... now do something
        }
    };
</script>

13a) "submit" binding details

- when you use the submit binding on a form, Knockout will prevent the browser’s default submit action for that form
- if you do want to let the form submit like a normal HTML form, just return true from your submit handler

14) Why not just put a click handler on the submit button?

- instead of using submit on the form, you could use click on the submit button 
- however, submit has the advantage that it also captures alternative ways to submit the form, such as pressing the enter key while typing into a text box

15) The enable binding

- The enable binding causes the associated DOM element to be enabled only when the parameter value is true
- This is useful with form elements like input, select, and textarea.

<p>
    <input type='checkbox' data-bind="checked: hasCellphone" />
    I have a cellphone
</p>
<p>
    Your cellphone number:
    <input type='text' data-bind="value: cellphoneNumber, enable: hasCellphone" />
</p>
 
<script type="text/javascript">
    var viewModel = {
        hasCellphone : ko.observable(false),
        cellphoneNumber: ""
    };
</script>

16) Using arbitrary JavaScript expressions

<button data-bind="enable: parseAreaCode(viewModel.cellphoneNumber()) != '555'">
    Do something
</button>

17) The "disable" binding

- The disable binding causes the associated DOM element to be disabled only when the parameter value is true
- This is the mirror image of the enable binding

18) The "value" binding

- The value binding links the associated DOM element’s value with a property on your view model. This is typically useful with form elements such as <input>, <select> and <textarea>

- When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.

<p>Login name: <input data-bind="value: userName" /></p>
<p>Password: <input type="password" data-bind="value: userPassword" /></p>
 
<script type="text/javascript">
    var viewModel = {
        userName: ko.observable(""),        // Initially blank
        userPassword: ko.observable("abc"), // Prepopulate
    };
</script>

19) valueUpdate

- by default the binding performs its actions on change events

- if your binding also includes a parameter called valueUpdate, this defines additional browser events KO should use to detect changes besides the change event


20) Using valueAllowUnset with <select> elements

<p>
    Select a country:
    <select data-bind="options: countries,
                       optionsCaption: 'Choose one...',
                       value: selectedCountry,
                       valueAllowUnset: true"></select>
</p>
 
<script type="text/javascript">
    var viewModel = {
        countries: ['Japan', 'Bolivia', 'New Zealand'],
        selectedCountry: ko.observable('Latvia')
    };
</script>

- In the above example, selectedCountry will retain the value 'Latvia', and the dropdown will be blank, because there is no corresponding option

- If valueAllowUnset had not been enabled, then Knockout would have overwritten selectedCountry with undefined, so that it would match the value of the 'Choose one...' caption entry

21) Updating observable and non-observable property values

<!-- Two-way binding. Populates textbox; syncs both ways. -->
<p>First value: <input data-bind="value: firstValue" /></p>
 
<!-- One-way binding. Populates textbox; syncs only from textbox to model. -->
<p>Second value: <input data-bind="value: secondValue" /></p>
 
<!-- No binding. Populates textbox, but doesn't react to any changes. -->
<p>Third value: <input data-bind="value: secondValue.length > 8" /></p>
 
<script type="text/javascript">
    var viewModel = {
        firstValue: ko.observable("hello"), // Observable
        secondValue: "hello, again"         // Not observable
    };
</script>

22) Using the value binding with the checked binding

- basically use checked binding for  checkbox (<input type='checkbox'>) or radio button (<input type='radio'>)
- don't use value binding

23 The "textInput" binding

- the textInput binding links a text box (<input>) or text area (<textarea>) with a viewmodel property
- it providing two-way updates between the viewmodel property and the element’s value

23a) textInput vs value binding

- Although the value binding can also perform two-way binding between text boxes and viewmodel properties, you should prefer textInput whenever you want immediate live updates + better browser event handling support

- Don’t try to use the value and textInput bindings together on the same element, as that won’t achieve anything useful

24) The "hasFocus" binding

- The hasFocus binding links a DOM element’s focus state with a viewmodel property. It is a two-way binding

25) Example: Click-to-edit

Source code: View

<p>
    Name: 
    <b data-bind="visible: !editing(), text: name, click: edit">&nbsp;</b>
    <input data-bind="visible: editing, value: name, hasFocus: editing" />
</p>
<p><em>Click the name to edit it; click elsewhere to apply changes.</em></p>

Source code: View model

function PersonViewModel(name) {
    // Data
    this.name = ko.observable(name);
    this.editing = ko.observable(false);
         
    // Behaviors
    this.edit = function() { this.editing(true) }
}
 
ko.applyBindings(new PersonViewModel("Bert Bertington"));

26) The "checked" binding

- The checked binding links a checkable form control — i.e., a checkbox (<input type='checkbox'>) or a radio button (<input type='radio'>) — with a property on your view model

- Note: For text boxes, drop-down lists, and all non-checkable form controls, use the value binding to read and write the element’s value, not the checked binding

27) checkedValue

- If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element’s value attribute

27a) Example

In the following example, the item objects themselves (not their itemName strings) will be included in the chosenItems array when their corresponding checkboxes are checked:

- I guess items are removed from chosenItems when checkboxes are unchecked

<!-- ko foreach: items -->
    <input type="checkbox" data-bind="checkedValue: $data, checked: $root.chosenItems" />
    <span data-bind="text: itemName"></span>
<!-- /ko -->
 
<script type="text/javascript">
    var viewModel = {
        items: ko.observableArray([
            { itemName: 'Choice 1' },
            { itemName: 'Choice 2' }
        ]),
        chosenItems: ko.observableArray()
    };
</script>


28) The "options" binding

- The options binding controls what options should appear in a drop-down list (i.e., a <select> element) or multi-select list (e.g., <select size='6'>)

- This binding cannot be used with anything other than <select> elements

28a) Additional parameters

- optionsCaption: use so that nothing is selected buy default
- optionsText: allows you to select which propertry of JS object to use as text in the <option> element
- optionsValue: specifies what property of JS object will be used as the value attribute of <option> element
- optionsIncludeDestroyed: non destructive delete; mark object as deleted (KO will ignore) but object still exists in memory
- optionsAfterRender: function that will run after KO creates <option element>
- selectedOptions: like 'value' binding for multi select list
- valueAllowUnset: allows your model property to take values that have no corresponding entry in your <select> element

29) The "selectedOptions" binding

- The selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a <select> element and the options binding.

- So there are two arrays in you view model
- one is the master list of what appears as options in the select element - "options" binding
- the other is a dynamic list of what is actually selected - "selectedOptions" binding

==== Example ====

<p>
    Choose some countries you'd like to visit: 
    <select data-bind="options: availableCountries, selectedOptions: chosenCountries" size="5" multiple="true"></select>
</p>
 
<script type="text/javascript">
    var viewModel = {
        availableCountries : ko.observableArray(['France', 'Germany', 'Spain']),
        chosenCountries : ko.observableArray(['Germany']) // Initially, only Germany is selected
    };
     
    // ... then later ...
    viewModel.chosenCountries.push('France'); // Now France is selected too
</script>

30) Letting the user select from arbitrary JavaScript objects

- In this scenario, the values you can read and write using selectedOptions are those objects themselves, not their textual representations

- i.e. not what is spcified by 'optionsText' binding

31) The "uniqueName" binding

- The uniqueName binding ensures that the associated DOM element has a nonempty name attribute. If the DOM element did not have a name attribute, this binding gives it one and sets it to some unique string value.

You won’t need to use this often. It’s only useful in a few rare cases, e.g.:

<input data-bind="value: someModelProperty, uniqueName: true" />

