
1) Loading and Saving JSON data (wrt your web app)

- use whatever mechanism you want to exchange data with server
- jQuery is a popular method

2) KO role 

- For saving, get your view model data into a simple JSON format so you can send it using one of the above techniques
- For loading, update your view model using data that you’ve received using one of the above techniques

3) Converting View Model Data to Plain JSON

- standard JSON serializers (native JSON.serialize or json2.js) don't work cleanly on KO view model objects
- becasue KO view model objects contain KO specific structures (observables)
- therefore KO includes helper funtions to assist in serializing KO view model objects

3a) ko.toJS 

— this clones your view model’s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts

var plainJs = ko.toJS(viewModel);

3b) ko.toJSON 

— this produces a JSON string representing your view model’s data. Internally, it simply calls ko.toJS on your view model, and then uses the browser’s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the json2.js library

var jsonData = ko.toJSON(viewModel);

4) Updating View Model Data using JSON

- best way is to load and parse the JSON using native js
- then manually build your view model

// Load and parse the JSON
var someJSON = /* Omitted: fetch it from the server however you want */;
var parsed = JSON.parse(someJSON);
 
// Update view model properties
viewModel.firstName(parsed.firstName);
viewModel.pets(parsed.pets);

- can automate the view model building process using the KO's mapping plugin

5) Using extenders to augment observables

- KO extenders provide an easy and flexible way to augment an observable (i.e. add functionality)
- this might include adding additional properties to the observable
- intercepting writes by placing a writable computed observable in front of the observable 
- whatever else etc

6) How to create an extender

- register your extender with KO
- target is the observable
- new value is what you are writing to the observable
- option is value ('first name') assigned to your extender (in this case logChange) 

ko.extenders.logChange = function(target, option) {
    target.subscribe(function(newValue) {
       console.log(option + ": " + newValue);
    });
    return target;
};

- use extender by calling extend function of an observable

this.firstName = ko.observable("Bob").extend({logChange: "first name"});

- if the firstName observable’s value was changed to Ted, then the console would show first name: Ted

7) Applying multiple extenders

- this.firstName = ko.observable(first).extend({ required: "Please enter a first name", logChange: "first name" });

8) Rate-limiting observable notifications

- rateLimit extender causes an observable to delay change notifications for a specified period of time
- rate-limited observable therefore updates dependencies asynchronously
- non rate-limited observable therefore updates dependencies asynchronously

9) Reasons to use rateLimit extender 

- making things respond after a certain delay
- combining multiple changes into a single update
- avoiding multiple Ajax requests, e.g. on a computed 

10) Applying the rateLimit extender

// Shorthand: Specify just a timeout in milliseconds
someObservableOrComputed.extend({ rateLimit: 500 });
 
// Longhand: Specify timeout and/or method
someObservableOrComputed.extend({ rateLimit: { timeout: 500, method: "notifyWhenChangesStop" } });

10a) possible value for 'method' parameter

- notifyAtFixedRate: default value if not otherwise specified; the notification happens after the specified period of time from the first change to the observable

- notifyWhenChangesStop: notification happens after no changes have occured to the observable for the specified period of time

11) Using unobtrusive event handlers

- the idea here is that you can attach event handlers to DOM element manually/individually using the data-bind attribute

- better way is to attach the event handlers at a higher level of abstracion; e.g. using jQuery's event handling. then in the event handler provide the data for the DOM element using ko.dataFor or ko.contextFor

- this way you just write the event handling code on time in a declarative fashion

12) Adding custom functions using "fn"

- see class diagram for inheritance structure (http://knockoutjs.com/documentation/fn.html)
- can add custon functions to classes using fn attribute for classes
- to attach a custom function, add it to one of the following extensibility points:

-- ko.subscribable.fn
-- ko.observable.fn
-- ko.observableArray.fn
-- ko.computed.fn

- then, your custom function will become available on all values of that type created from that point onwards

13) Extending Knockout's binding syntax using preprocessing

- this is an advanced technique and not something you will normally do

- you can hook into Knockout’s logic for interpreting data-bind attributes by providing a binding preprocessor for a specific binding handler (such as click, visible, or any custom binding handler)

to do this, attach a preprocess function to the binding handler:

ko.bindingHandlers.yourBindingHandler.preprocess = function(stringFromMarkup) {
    // Return stringFromMarkup if you don't want to change anything, or return
    // some other string if you want Knockout to behave as if that was the
    // syntax provided in the original HTML
}

