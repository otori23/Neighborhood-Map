
1) Writable computed observables

- normally read only because they are computed for other observables
- to make computed observables writable, supply your own callback function that does something sensible with written values
- your custom logic intercepts all reads and writes then does something useful

=== Source code: View ===

<div>First name: <span data-bind="text: firstName"></span></div>
<div>Last name: <span data-bind="text: lastName"></span></div>
<div class="heading">Hello, <input data-bind="textInput: fullName"/></div>


=== Source code: View model ===

function MyViewModel() {
    this.firstName = ko.observable('Planet');
    this.lastName = ko.observable('Earth');
 
    this.fullName = ko.pureComputed({
        read: function () {
            return this.firstName() + " " + this.lastName();
        },
        write: function (value) {
            var lastSpacePos = value.lastIndexOf(" ");
            if (lastSpacePos > 0) { // Ignore values with no space character
                this.firstName(value.substring(0, lastSpacePos)); // Update "firstName"
                this.lastName(value.substring(lastSpacePos + 1)); // Update "lastName"
            }
        },
        owner: this
    });
}
 
ko.applyBindings(new MyViewModel());

2) Situations where KO computed observables can be used

- Decomposing user input
- Selecting/deselecting all items
- A value converter: data on screen is formatted differently than underlying data model
- Filtering and validating user input (can use JQuery validation mechanism instead)